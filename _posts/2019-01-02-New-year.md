---
layout: post
title: Scheming and structuring
tags: scheme lisp meta
description: Venturing through SICP, hopefully i learn something new.
---

Hey, my last post was last year, isn't that interesting ?


...



~~#overused jokes~~


# SICP #

Been going through [Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sites/default/files/sicp/index.html) lately because i heard it was a decent book.

It starts off pretty good, it's definitely not your regular tutorial about some specific language or even some specific paradigm really, but it's rather about computers in general, about how ideas are expressed in a way computers can understand them (well, as much as computers "understand" ideas (and that might actually be an interesting topic potentially)), it is about the *processes* that run in the *spirit of the computer*.


Yeah I hear it's a very special book.

Anyways, so far it's been a fairly interesting journey, I'm not very advanced in it (Chapter 2), but it does introduce you to some fairly interesting stuff early on (maps, filters & higher level functions in general).

## My own progress ##
I am documenting my own progress throughout the book in a GitHub repository [here](https://github.com/zenAndroid/Scheming), for archiving purposes.

## Commentary ##

Well, I am mostly looking for the next chapters and what they have to offer, but these previous ones have been quite interesting:

#### Building abstraction with Procedures ####

First chapter was very refreshing even though the ideas presented in it were not necessarily new, i think the reason for this is mainly the very interesting exercises that accompany the material.

##### The elements of programming #####

Quick introduction and yet it very rapidly manages to reliably and understandably foreshadow key concepts needed in the advancement of the book.

##### Procedures and the processes they generate #####

How surprisingly refreshing it is to see an allegedly introductory book go straight into the deep depths of recursion (well, okay i admit i may have overstated that) and mention The concept of big-O notations and such ...

```
In this section we will examine some common “shapes” for pro-
cesses generated by simple procedures. We will also investigate the
rates at which these processes consume the important computational
resources of time and space. The procedures we will consider are very
simple. Their role is like that played by test patterns in photography: as
oversimplified prototypical patterns, rather than practical examples in
their own right.
```

I am a great admirer of the use of abstract language to describe things in this book.

I also loved exercise 1.13

![Exo1-13]({{"/assets/exo1-13.png" | absolute_url }})


Also, yay for lambda.

Also the `let` keyword always confused me at first, but I think I understood it after some more practice.

I'll have to take a look at the **Procedures as General Methods** section :thinking:

I *absolutely* loved the continuous fractions exercise, and maybe I'm biased because i love only the exercises I solve, but still, so .... *Simple and clean* ... While i haven't tested this yet, I'm willing to bet that solving this exercise in any other language would result in a lot more headaches (If that programming language does not provide higher order functions) i think.

Same goes for the tangent function ![Tangent]({{"/assets/tangent-SICP.png" | absolute_url }})

I'll have to take a look at the **Procedures as Returned Values** section :thinking:
